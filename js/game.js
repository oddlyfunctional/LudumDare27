// Generated by CoffeeScript 1.3.3
(function() {

  window.addEventListener("load", function() {
    var Q, assets;
    Q = window.Q = Quintus().include("Sprites, Scenes, Input, Audio, 2D, Anim, Touch, UI").setup({
      width: 768,
      height: 480
    }).controls().touch();
    Q.input.mouseControls();
    Q.input.keyboardControls();
    Q.enableSound();
    Q.el.style.cursor = 'auto';
    Q.FloorHeight = 450;
    Q.LevelWidth = 3840;
    Q.Vector = {
      subtract: function(v1, v2) {
        return {
          x: v1.x - v2.x,
          y: v1.y - v2.y
        };
      },
      distance: function(v1, v2) {
        return Math.sqrt(Math.pow(v1.x - v2.x, 2) + Math.pow(v1.y - v2.y, 2));
      }
    };
    Q.pointInside = function(point, o) {
      var c, ox, oy;
      c = o.c || o.p;
      ox = c.x - c.cx;
      oy = c.y - c.cy;
      return !((oy + c.h <= point.y) || (oy >= point.y) || (ox + c.w <= point.x) || (ox >= point.x));
    };
    Q.component("extendedMouseEvents", {
      mouseInside: function() {
        var mouseX, mouseY;
        mouseX = Q.inputs["mouseX"];
        mouseY = Q.inputs["mouseY"];
        return Q.pointInside({
          x: mouseX,
          y: mouseY
        }, this.entity);
      },
      added: function() {
        var mouseClick, mouseDown, mouseEnter, mouseLeave,
          _this = this;
        mouseDown = function() {
          return _this.entity.trigger("mouseDown");
        };
        Q.el.addEventListener.apply(Q.el, ["mousedown", mouseDown, false]);
        mouseClick = function() {
          if (_this.mouseInside()) {
            return _this.entity.trigger("click");
          }
        };
        Q.el.addEventListener.apply(Q.el, ["mousedown", mouseClick, false]);
        mouseEnter = function() {
          if (!_this.inside && _this.mouseInside()) {
            _this.inside = true;
            return _this.entity.trigger("mouseEnter");
          }
        };
        Q.el.addEventListener.apply(Q.el, ["mousemove", mouseEnter, false]);
        mouseLeave = function() {
          if (_this.inside && !_this.mouseInside()) {
            _this.inside = false;
            return _this.entity.trigger("mouseLeave");
          }
        };
        return Q.el.addEventListener.apply(Q.el, ["mousemove", mouseLeave, false]);
      }
    });
    Q.component("sticker", {
      added: function() {
        return this.entity.on("step", this, "step");
      },
      step: function(dt) {
        if (this.entity._stickerActive) {
          this.entity.p.x = Q.inputs["mouseX"];
          return this.entity.p.y = Q.inputs["mouseY"];
        }
      }
    });
    Q.Sprite.extend("Player", {
      click: function() {
        return console.log("click");
      },
      hover: function() {
        return console.log("hover");
      },
      init: function(p) {
        this._super(p, {
          sheet: "player",
          sprite: "player",
          x: 400,
          y: Q.FloorHeight
        });
        this.p.y -= this.p.h / 2;
        this.speed = 50;
        if (Q.DEBUG) {
          if (Q.DEBUG.SPEED) {
            this.speed = 600;
          }
        }
        this.add("2d, animation");
        this.play("right");
        Q.input.on("left", this, this.turnLeft);
        Q.input.on("right", this, this.turnRight);
        return this.on("hit.sprite", function(collision) {
          if (collision.obj.isA("Tower")) {
            Q.stageScene("endGame", 1, {
              label: "You Won!"
            });
            return this.destroy();
          }
        });
      },
      turnLeft: function() {
        return this.play("left");
      },
      turnRight: function() {
        return this.play("right");
      },
      busted: function() {
        return console.log("busted!");
      },
      addSpotLight: function(spotLight) {
        this.spotLights || (this.spotLights = []);
        return this.spotLights.push(spotLight);
      },
      addEnemy: function(enemy) {
        this.enemies || (this.enemies = []);
        return this.enemies.push(enemy);
      },
      withinRange: function(object, range) {
        return Math.abs(this.p.x - object.p.x) <= range;
      },
      checkSpotLights: function() {
        var spotLight, _i, _len, _ref, _results;
        this.visible = false;
        _ref = this.spotLights;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          spotLight = _ref[_i];
          if (this.withinRange(spotLight, spotLight.range)) {
            _results.push(this.visible = true);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      distanceFromEnemy: function(enemy) {
        var distance;
        distance = 0;
        if (enemy.direction() === "left") {
          distance = (enemy.p.x - enemy.range) - this.p.x;
        } else {
          distance = this.p.x - (enemy.p.x + enemy.range);
        }
        return Math.abs(distance);
      },
      checkEnemies: function() {
        var enemy, enemyX, newDistance, turnedToPlayer, x, _i, _len, _ref, _results;
        x = this.p.x;
        this.closestEnemy = Infinity;
        _ref = this.enemies;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          enemy = _ref[_i];
          enemyX = enemy.p.x;
          turnedToPlayer = (enemy.direction() === "left" && x < enemyX) || (enemy.direction() === "right" && x > enemyX);
          if (turnedToPlayer) {
            newDistance = this.distanceFromEnemy(enemy);
            if (newDistance < this.closestEnemy) {
              this.closestEnemy = newDistance;
            }
            if (this.visible && this.withinRange(enemy, enemy.range)) {
              _results.push(this.busted());
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      step: function(dt) {
        if (Q.inputs["left"]) {
          this.p.vx = -this.speed;
          this.p.direction = "left";
        } else if (Q.inputs["right"]) {
          this.p.vx = this.speed;
          this.p.direction = "right";
        } else {
          this.p.vx = 0;
        }
        if (this.p.vx === 0) {
          this.play("standing");
        }
        this.checkSpotLights();
        return this.checkEnemies();
      },
      draw: function(ctx) {
        var difference, length, mousePoint;
        this._super(ctx);
        if (Q.DEBUG) {
          ctx.fillStyle = "rgba(0,255,255, 0.5)";
          ctx.fillRect(-this.p.cx, 0, this.p.w, 10);
          mousePoint = {
            x: Q.inputs["mouseX"],
            y: Q.inputs["mouseY"]
          };
          length = Q.Vector.distance(this.p, mousePoint);
          difference = Q.Vector.subtract(mousePoint, this.p);
          ctx.fillStyle = "grey";
          ctx.fillText("x: " + this.p.x + " y: " + this.p.y, 0, -200);
          ctx.rotate(Math.atan2(difference.y, difference.x));
          return ctx.fillRect(0, 0, length, 10);
        }
      }
    });
    Q.Sprite.extend("ProximityAlert", {
      init: function(options) {
        this._super(options, {
          asset: "exclamacao.png"
        });
        this.maximumAlert = 100;
        this.p.x = this.p.player.p.x;
        return this.p.y = (this.p.player.p.y - this.p.player.p.h / 2) - this.p.h / 2;
      },
      step: function(dt) {
        return this.p.x = this.p.player.p.x;
      },
      draw: function(ctx) {
        if (this.p.player.visible) {
          this.p.asset = "exclamacao.png";
          this._super(ctx);
          ctx.globalAlpha = this.maximumAlert / this.p.player.closestEnemy;
          this.p.asset = "exclamacao_red.png";
          return this._super(ctx);
        }
      }
    });
    Q.Sprite.extend("SpotLight", {
      init: function(options) {
        this._super(options);
        this.range = options["range"] || 100;
        return options["player"].addSpotLight(this);
      },
      draw: function(ctx) {
        this._super(ctx);
        if (Q.DEBUG) {
          ctx.fillStyle = "yellow";
          return ctx.fillRect(-this.range, 0, this.range * 2, 10);
        }
      }
    });
    Q.Sprite.extend("Enemy", {
      init: function(options) {
        this._super(options, {
          sprite: "enemy_1",
          sheet: "enemy_1",
          y: Q.FloorHeight,
          vx: -100,
          type: Q.SPRITE_NONE
        });
        this.p.y -= this.p.h / 2;
        this.left_limit = options["left_limit"];
        this.right_limit = options["right_limit"];
        this.speed = options["speed"] || 100;
        this.range = options["range"] || 200;
        this.flashlightRange = options["flashlightRange"] || 100;
        options["player"].addEnemy(this);
        this.add("2d, animation");
        return this.play("right");
      },
      direction: function() {
        if (this.p.vx < 0) {
          return "left";
        } else {
          return "right";
        }
      },
      draw: function(ctx) {
        this._super(ctx);
        if (Q.DEBUG) {
          ctx.fillStyle = "blue";
          if (this.direction() === "left") {
            ctx.fillRect(-this.range, 0, this.range, 10);
          } else {
            ctx.fillRect(0, 0, this.range, 10);
          }
          ctx.fillStyle = "red";
          if (this.direction() === "left") {
            return ctx.fillRect(-this.flashlightRange, 0, this.flashlightRange, 10);
          } else {
            return ctx.fillRect(0, 0, this.flashlightRange, 10);
          }
        }
      },
      step: function(dt) {
        var new_vx, new_x;
        new_x = this.p.x + this.p.vx * dt;
        new_vx = this.p.vx === 0 ? this.speed : this.p.vx;
        if (this.direction() === "left" && new_x <= this.left_limit) {
          new_vx = this.speed;
        }
        if (this.direction() === "right" && new_x >= this.right_limit) {
          new_vx = -this.speed;
        }
        this.p.vx = new_vx;
        if (this.direction() === "left" && this.p.animation !== "left") {
          return this.play("left");
        } else if (this.direction() === "right" && this.p.animation !== "right") {
          return this.play("right");
        }
      }
    });
    Q.Sprite.extend("MenuItem", {
      init: function(options) {
        this._super(options, {
          type: Q.SPRITE_UI
        });
        this.offsetX = this.p.x;
        this.offsetY = this.p.y;
        if (options.sticker) {
          this.add("extendedMouseEvents, sticker");
        } else {
          this.add("extendedMouseEvents");
        }
        this.on("click", "click");
        this.on("mouseEnter", function() {
          return Q.el.style.cursor = "pointer";
        });
        return this.on("mouseLeave", function() {
          return Q.el.style.cursor = "auto";
        });
      },
      step: function(dt) {
        if (!this._stickerActive) {
          this.p.x = Q.stage().viewport.x + this.offsetX;
          return this.p.y = this.offsetY;
        }
      },
      click: function() {
        if (Q.SelectedItem != null) {
          if (Q.SelectedItem === this) {
            if (this.p.useHandler) {
              this.p.useHandler();
            }
            if (this._stickerActive) {
              this._stickerActive = false;
            }
            return Q.SelectedItem = null;
          }
        } else {
          if (this.p.selectHandler) {
            this.p.selectHandler();
          }
          if (this.p.sticker) {
            this._stickerActive = true;
          }
          return Q.SelectedItem = this;
        }
      }
    });
    Q.Sprite.extend("Door", {
      init: function(options) {
        this._super(options, {
          y: Q.FloorHeight - 79,
          h: 123,
          w: 95,
          type: 0
        });
        this.on("phonecall", "ring");
        this.on("click", "teste");
        return this.add("extendedMouseEvents");
      },
      teste: function() {
        return console.log("TESTE");
      }
    });
    Q.Sprite.extend("LevelCollider", {
      init: function(options) {
        this._super(options);
        this.leftWall = {
          p: {
            w: 10,
            h: 768,
            x: 360,
            y: 0
          }
        };
        return this.rightWall = {
          p: {
            w: 10,
            h: 768,
            x: 3400,
            y: 0
          }
        };
      },
      collide: function(obj) {
        return Q.collision(obj, this.leftWall) || Q.collision(obj, this.rightWall);
      }
    });
    Q.scene("level1", function(stage) {
      var i, nSpotLights, spotLightDistance, spotLightOffset, _i;
      window.bg = new Q.Sprite({
        asset: "corredor.png",
        x: Q.LevelWidth / 2,
        y: 480 / 2,
        type: 0
      });
      stage.insert(bg);
      stage.collisionLayer(new Q.LevelCollider());
      stage.insert(new Q.Door({
        x: 207
      }));
      window.player = stage.insert(new Q.Player());
      stage.insert(new Q.ProximityAlert({
        player: player
      }));
      stage.add("viewport").follow(player, {
        y: false,
        x: true
      });
      stage.insert(new Q.MenuItem({
        x: 60,
        y: 70,
        asset: "cellphone.png",
        sticker: true
      }));
      stage.insert(new Q.MenuItem({
        x: 200,
        y: 70,
        asset: "grampeador.png",
        sticker: true
      }));
      stage.insert(new Q.Enemy({
        x: 900,
        player: player,
        left_limit: 500,
        right_limit: 2000,
        range: 200
      }));
      spotLightOffset = 358;
      spotLightDistance = 425;
      nSpotLights = Math.floor((Q.LevelWidth - spotLightOffset) / spotLightDistance);
      for (i = _i = 0; 0 <= nSpotLights ? _i <= nSpotLights : _i >= nSpotLights; i = 0 <= nSpotLights ? ++_i : --_i) {
        stage.insert(new Q.SpotLight({
          x: spotLightOffset + spotLightDistance * i,
          y: 430,
          player: player,
          range: 80
        }));
      }
      if (!Q.DEBUG) {
        return Q.audio.play("bg.mp3", {
          loop: true
        });
      }
    });
    Q.Sprite.extend("Intro", {
      init: function(options) {
        this._super(options, {
          x: 0,
          y: 0,
          cx: 0,
          cy: 0
        });
        this.timer = 0;
        this.frameCount = 0;
        this.framesNames = ["escritorio_luz.png", "escritorio.png", "escritorio_apagado.png", "escritorio_assassinato.png"];
        this.frameEvents = [1, 2, 3, 4, 5, 6, 7, 8, 9, 13];
        this.framePerEvent = [0, 1, 0, 1, 0, 1, 0, 1, 2, 3];
        this.frameChanged = false;
        this.audioCount = 0;
        this.audioEvents = [0, 1, 13];
        this.audioPerEvent = ["cello.mp3", "train.mp3", "brokenString.mp3"];
        return this.audioChanged = false;
      },
      step: function(dt) {
        this.timer += dt;
        if (this.frameCount < this.frameEvents.length && this.timer >= this.frameEvents[this.frameCount]) {
          this.p.asset = this.framesNames[this.framePerEvent[this.frameCount]];
          console.log(this.p.asset);
          this.frameCount++;
        }
        if (this.audioCount < this.audioEvents.length && this.timer >= this.audioEvents[this.audioCount]) {
          console.log("AUDIO: " + this.audioPerEvent[this.audioCount]);
          console.log("Timer: " + this.timer);
          Q.audio.play(this.audioPerEvent[this.audioCount]);
          return this.audioCount++;
        }
      }
    });
    Q.scene("intro", function(stage) {
      return stage.insert(new Q.Intro());
    });
    Q.scene("endGame", function(stage) {
      var button, container, label;
      container = stage.insert(new Q.UI.Container({
        x: Q.width / 2,
        y: Q.height / 2,
        fill: "rgba(0,0,0,0.5)"
      }));
      button = container.insert(new Q.UI.Button({
        x: 0,
        y: 0,
        fill: "#CCCCCC",
        label: "Play Again"
      }));
      label = container.insert(new Q.UI.Text({
        x: 10,
        y: -10 - button.p.h,
        label: stage.options.label
      }));
      button.on("click", function() {
        Q.clearStages();
        return Q.stageScene("level1");
      });
      return container.fit(20);
    });
    Q.DEBUG = {
      SPEED: true,
      IDCLIP: true
    };
    Q.debug = true;
    Q.debug = false;
    Q.DEBUG = false;
    assets = "escritorio.png, escritorio_luz.png, escritorio_apagado.png, escritorio_assassinato.png, exclamacao.png, exclamacao_red.png, enemy_1.png, player.png, corredor.png, grampeador.png, key.png, cellphone.png";
    if (!Q.debug) {
      assets += ", bg.mp3, cello.mp3, train.mp3, brokenString.mp3";
    }
    return Q.load(assets, function() {
      Q.gravityY = 0;
      Q.input.keyboardControls({
        65: "left",
        68: "right"
      });
      Q.sheet("player", "player.png", {
        tilew: 105,
        tileh: 123,
        sx: 0,
        sy: 0
      });
      Q.sheet("enemy_1", "enemy_1.png", {
        tilew: 70,
        tileh: 128
      });
      Q.animations("player", {
        standing: {
          frames: [28],
          rate: 1
        },
        right: {
          frames: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
          rate: 1 / 5
        },
        left: {
          frames: [14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27],
          rate: 1 / 5
        }
      });
      Q.animations("enemy_1", {
        right: {
          frames: [0, 1, 2],
          rate: 1 / 3
        },
        left: {
          frames: [3, 4, 5],
          rate: 1 / 3
        }
      });
      return Q.stageScene("intro");
    }, {
      progressCallback: function(loaded, total) {
        var element;
        element = document.getElementById("loading_progress");
        element.style.width = Math.floor(loaded / total * 100) + "%";
        if (loaded === total) {
          return document.getElementById("loading").style.display = "none";
        }
      }
    });
  });

}).call(this);
