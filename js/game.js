// Generated by CoffeeScript 1.3.3
(function() {

  window.addEventListener("load", function() {
    var Q;
    Q = window.Q = Quintus().include("Sprites, Scenes, Input, 2D, Anim, Touch, UI").setup({
      width: 768,
      height: 480
    }).controls().touch();
    Q.FloorHeight = 450;
    Q.Sprite.extend("Player", {
      init: function(p) {
        this._super(p, {
          sheet: "player_front",
          x: 100,
          y: Q.FloorHeight
        });
        this.p.y -= this.p.h / 2;
        this.speed = 200;
        this.add("2d");
        Q.input.on("fire", this, "action");
        return this.on("hit.sprite", function(collision) {
          if (collision.obj.isA("Tower")) {
            Q.stageScene("endGame", 1, {
              label: "You Won!"
            });
            return this.destroy();
          }
        });
      },
      busted: function() {
        return console.log("busted!");
      },
      addSpotLight: function(spotLight) {
        this.spotLights || (this.spotLights = []);
        return this.spotLights.push(spotLight);
      },
      addEnemy: function(enemy) {
        this.enemies || (this.enemies = []);
        return this.enemies.push(enemy);
      },
      withinRange: function(object, range) {
        return Math.abs(this.p.x - object.p.x) <= range;
      },
      checkSpotLights: function() {
        var spotLight, _i, _len, _ref, _results;
        this.visible = false;
        _ref = this.spotLights;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          spotLight = _ref[_i];
          if (this.withinRange(spotLight, spotLight.range)) {
            _results.push(this.visible = true);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      checkEnemies: function() {
        var enemy, enemyX, turnedToPlayer, x, _i, _len, _ref, _results;
        x = this.p.x;
        _ref = this.enemies;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          enemy = _ref[_i];
          enemyX = enemy.p.x;
          turnedToPlayer = (enemy.direction() === "left" && x < enemyX) || (enemy.direction() === "right" && x > enemyX);
          if (turnedToPlayer) {
            if (this.visible && this.withinRange(enemy, enemy.range) || this.withinRange(enemy, enemy.flashlightRange)) {
              _results.push(this.busted());
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      step: function(dt) {
        if (Q.inputs["left"]) {
          this.p.vx = -this.speed;
          this.p.direction = "left";
        } else if (Q.inputs["right"]) {
          this.p.vx = this.speed;
          this.p.direction = "right";
        } else {
          this.p.vx = 0;
        }
        this.checkSpotLights();
        return this.checkEnemies();
      },
      action: function() {
        return console.log("action!");
      }
    });
    Q.Sprite.extend("Tower", {
      init: function(p) {
        return this._super(p, {
          sheet: "tower"
        });
      }
    });
    Q.Sprite.extend("SpotLight", {
      init: function(options) {
        this._super(options, {
          sheet: "tower"
        });
        this.range = options["range"] || 100;
        return options["player"].addSpotLight(this);
      }
    });
    Q.Sprite.extend("Enemy", {
      init: function(options) {
        this._super(options, {
          sheet: "enemy",
          y: Q.FloorHeight,
          vx: -100
        });
        this.left_limit = options["left_limit"];
        this.right_limit = options["right_limit"];
        this.speed = options["speed"] || 100;
        this.range = options["range"] || 200;
        this.flashlightRange = options["flashlightRange"] || 100;
        options["player"].addEnemy(this);
        return this.add("2d");
      },
      direction: function() {
        if (this.p.vx < 0) {
          return "left";
        } else {
          return "right";
        }
      },
      step: function(dt) {
        var new_vx, new_x;
        new_x = this.p.x + this.p.vx * dt;
        new_vx = this.p.vx === 0 ? this.speed : this.p.vx;
        if (this.direction() === "left" && new_x <= this.left_limit) {
          new_vx = this.speed;
        }
        if (this.direction() === "right" && new_x >= this.right_limit) {
          new_vx = -this.speed;
        }
        return this.p.vx = new_vx;
      }
    });
    Q.Sprite.extend("LevelCollider", {
      init: function(options) {
        this._super(options);
        this.leftWall = {
          p: {
            w: 10,
            h: 768,
            x: 0,
            y: 0
          }
        };
        return this.rightWall = {
          p: {
            w: 10,
            h: 768,
            x: 1280,
            y: 0
          }
        };
      },
      collide: function(obj) {
        return Q.collision(obj, this.leftWall) || Q.collision(obj, this.rightWall);
      }
    });
    Q.scene("level1", function(stage) {
      var player;
      window.bg = new Q.Sprite({
        asset: "corredor.png",
        x: 800 / 2,
        y: 480 / 2,
        type: 0
      });
      console.log(bg);
      stage.insert(bg);
      stage.collisionLayer(new Q.LevelCollider());
      player = stage.insert(new Q.Player());
      stage.add("viewport").follow(player, {
        y: false,
        x: true
      });
      stage.insert(new Q.Enemy({
        x: 700,
        player: player,
        left_limit: 500,
        right_limit: 750,
        range: 200
      }));
      stage.insert(new Q.SpotLight({
        x: 400,
        y: 50,
        player: player,
        range: 100
      }));
      return stage.insert(new Q.SpotLight({
        x: 0,
        y: 50,
        player: player,
        range: 100
      }));
    });
    Q.scene("endGame", function(stage) {
      var button, container, label;
      container = stage.insert(new Q.UI.Container({
        x: Q.width / 2,
        y: Q.height / 2,
        fill: "rgba(0,0,0,0.5)"
      }));
      button = container.insert(new Q.UI.Button({
        x: 0,
        y: 0,
        fill: "#CCCCCC",
        label: "Play Again"
      }));
      label = container.insert(new Q.UI.Text({
        x: 10,
        y: -10 - button.p.h,
        label: stage.options.label
      }));
      button.on("click", function() {
        Q.clearStages();
        return Q.stageScene("level1");
      });
      return container.fit(20);
    });
    return Q.load("sprites.png, player_front.png, tiles.png, corredor.png, sprites.json", function() {
      Q.gravityY = 0;
      Q.sheet("player_front", "player_front.png", {
        tilew: 35,
        tileh: 118,
        sx: 0,
        sy: 0
      });
      Q.compileSheets("sprites.png", "sprites.json");
      return Q.stageScene("level1");
    });
  });

}).call(this);
